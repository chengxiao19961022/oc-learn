// 注意代码的执行顺序和刷新

// 不要轻易增删改不懂的代码，如果改了要知道改的位置，并在排查时思考这些代码的意义。

// 调用presentViewController  present方法适合用在呈现单独的页面，dissmiss后不会影响当前的堆栈
    [self presentViewController:(nonnull UIViewController *) animated:(BOOL) completion:^(void)completion];
// presentViewController退回
    [self dismissViewControllerAnimated:(BOOL) completion:^(void)completion]；

// pop到根目录下
    [self.navigationController popToRootViewControllerAnimated:YES];

// pop到指定目录
    [self.navigationController popToViewController:VC animated:YES]

// navigationcontroller push
    [self.navigationController pushViewController:rootVC animated:YES];

// 遍历所有根控制器的子控制器并做判断跳转
    [self.navigationController.childViewControllers enumerateObjectsUsingBlock:^(__kindof UIViewController * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    if ([obj isKindOfClass:[MyOrderViewController class]]) {
        //   pop到指定obj并有跳转动画
    [Utils setNavigationControllerPopWithAnimation:self timingFunction:KYNaviAnimationTimingFunctionEaseInEaseOut type:KYNaviAnimationTypeReveal subType:KYNaviAnimationDirectionDefault duration:0.38 target:obj];
    toMyORderVC = YES;
    }
    }];
// childview的使用方法
    //在ViewController 中添加其他UIViewController，currentVC是一个UIViewController变量，存储当前显示的viewcontroller
    FirstVC * first = [[FirstVC alloc] init];
    [self addChildViewController:first];
    //addChildViewController 会调用 [child willMoveToParentViewController:self] 方法，但是不会调用 didMoveToParentViewController:方法，官方建议显示调用
    [first didMoveToParentViewController:self];
    [first.view setFrame:CGRectMake(0, CGRectGetMaxY(myScrollView.frame), width, height-CGRectGetHeight(myScrollView.frame))];
    currentVC = first;
    [self.view addSubview:currentVC.view];
    //这里没有其他addSubview:方法了，就只有一个，而且可以切换视图，是不是很神奇？
    second = [[SecondVC alloc] init];
    [second.view setFrame:CGRectMake(0,CGRectGetMaxY(myScrollView.frame), width, height-CGRectGetHeight(myScrollView.frame))];


//  遍历所有navigationcontroller堆栈的控制器并做判断跳转，这些控制器确实存在于堆栈中
    for (UIViewController *VC in self.navigationController.viewControllers) {
    if ([VC isKindOfClass:[LoginViewController class]]) {
    [self.navigationController popToViewController:VC animated:YES]
    }
    }

// 添加跳转动画
    [current.navigationController.view.layer addAnimation:animation forKey:nil];

// 改变并切换到根目录
    wyTabBarController *rootVC = [[wyTabBarController alloc] init];
    AppDelegate *app = KappDelegate;
    UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:rootVC];
    app.window.rootViewController = nav;

// 发通知
    [[NSNotificationCenter defaultCenter] postNotificationName:@"GuidanceToAPP" object:@""];

// 接收通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(loginApp:) name:@"GuidanceToAPP" object:nil];
    -(void)loginApp:(NSNotification*)aNotification{
    [aNotification object];
    }

// 注销通知
    [[NSNotificationCenter  defaultCenter] removeObserver:self  name:@"GuidanceToApp" object:nil];

// 初始化并定义frame大小
    self.mytableview = [[UITableView alloc]initWithFrame:CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height-64)];

    CGRect newFrame = self.headerView.frame;
    newFrame.size.height = newFrame.size.height + 36 + 38;
    self.headerView.frame = newFrame;
    [self.tbView beginUpdates];
    [self.tbView setTableHeaderView:self.headerView];
    [self.tbView endUpdates];


// 添加约束
    NSLayoutConstraint *topConstraint = [NSLayoutConstraint constraintWithItem:self.mytableview attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.rdv_tabBarController.navigationController.navigationBar attribute:NSLayoutAttributeTop multiplier:1.0 constant:self.rdv_tabBarController.navigationController.navigationBar.height];
    [self.view addConstraint:topConstraint];
    __block MASConstraint *constraintNoOrder = nil;
    __block MASConstraint *constraintHasOrder = nil;
    [ViewArr.firstObject mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.mas_equalTo(20);
    //make.height.mas_equalTo(325);
    int rm_width = [UIScreen mainScreen].bounds.size.width/2 - 25;
    make.height.mas_equalTo(rm_width * 2);
    //make.width.mas_equalTo([UIScreen mainScreen].bounds.size.width/2 - 20);
    constraintNoOrder = make.top.mas_equalTo(20).with.priority(999);
    constraintHasOrder = make.top.equalTo(orderView.mas_bottom).with.offset(20);
    make.right.mas_equalTo(-20);
    }];
    [constraintNoOrder uninstall];
    [constraintHasOrder uninstall];

// 判断数据类型
    [obj isKindOfClass:[MyOrderViewController class]]

// 设置UIView的背景
    UIColor *bgColor = [UIColor colorWithPatternImage: [UIImage imageNamed:@"jbbg"]];
    [naviView.bgView setBackgroundColor:bgColor];

// 隐藏自动刷新状态栏
    self.edgesForExtendedLayout = UIRectEdgeNone;
    self.extendedLayoutIncludesOpaqueBars = NO;
    self.modalPresentationCapturesStatusBarAppearance = NO;
    self.automaticallyAdjustsScrollViewInsets=NO;

    header.lastUpdatedTimeLabel.hidden = YES;
    header.stateLabel.hidden = YES;

// 解决标题栏上移的问题
    定义静态属性：
        BOOL _wasKeyboardManagerEnabled;
    在viewDidappear里：
        _wasKeyboardManagerEnabled = [[IQKeyboardManager sharedManager] isEnabled];
        [[IQKeyboardManager sharedManager] setEnable:NO];
    在viewWillDisappear里：
        [[IQKeyboardManager sharedManager] setEnable:_wasKeyboardManagerEnabled];



